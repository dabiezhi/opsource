// ---Auto Generated by Only4Play ---
package com.only4play.flow.domain.chain.service;

import java.util.Optional;

import com.only4play.flow.domain.chain.Chain;
import com.only4play.flow.domain.chain.QChain;
import com.only4play.flow.domain.chain.dto.ChainCreateReq;
import com.only4play.flow.domain.chain.dto.ChainQueryReq;
import com.only4play.flow.domain.chain.dto.ChainReleaseReq;
import com.only4play.flow.domain.chain.dto.ChainResp;
import com.only4play.flow.domain.chain.dto.ChainUpdateReq;
import com.only4play.flow.domain.chain.dto.creator.ChainCreator;
import com.only4play.flow.domain.chain.dto.updater.ChainUpdater;
import com.only4play.flow.domain.chain.mapper.ChainMapper;
import com.only4play.flow.domain.chain.repository.ChainRepository;
import com.only4play.jpa.support.EntityOperations;
import com.querydsl.core.BooleanBuilder;

import cn.hutool.core.util.StrUtil;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Transactional
@Service
@Slf4j
@RequiredArgsConstructor
public class ChainServiceImpl implements IChainService {
    private final ChainRepository chainRepository;


    @Override
    public Long createChain(ChainCreateReq request) {
        ChainCreator creator = ChainMapper.INSTANCE.req2Creator(request);
        Optional<Chain> chain = EntityOperations.doCreate(chainRepository).create(
                () -> ChainMapper.INSTANCE.creator2Entity(creator)).update(e -> e.init()).execute();
        return chain.isPresent() ? chain.get().getId() : 0;
    }


    @Override
    public void updateChain(ChainUpdateReq request) {
        ChainUpdater updater = ChainMapper.INSTANCE.req2Updater(request);
        EntityOperations.doUpdate(chainRepository)
                .loadById(updater.getId())
                .update(e -> updater.updateChain(e))
                .execute();
    }


    @Override
    public void releaseChain(ChainReleaseReq request) {
        ChainUpdater updater = ChainMapper.INSTANCE.req2Updater(request);
        EntityOperations.doUpdate(chainRepository).loadById(updater.getId()).update(
                e -> updater.releaseChain(e).release()).execute();
    }

    /**
     * valid
     */
    @Override
    public void validChain(Long id) {
        EntityOperations.doUpdate(chainRepository).loadById(id).update(e -> e.valid()).execute();
    }

    /**
     * invalid
     */
    @Override
    public void invalidChain(Long id) {
        EntityOperations.doUpdate(chainRepository).loadById(id).update(e -> e.invalid()).execute();
    }

    /**
     * delete
     */
    @Override
    public void deleteChain(Long id) {
        chainRepository.deleteById(id);
    }

    /**
     * findById
     */
    @Override
    public ChainResp findById(Long id) {
        Optional<Chain> chain = chainRepository.findById(id);
        return chain.map(ChainMapper.INSTANCE::entity2Response).orElse(null);
    }

    /**
     * findByPage
     */
    @Override
    public Page<ChainResp> findByPage(ChainQueryReq req) {
        BooleanBuilder booleanBuilder = new BooleanBuilder();
        if (StrUtil.isNotBlank(req.getChainName())) {
            booleanBuilder.and(QChain.chain.chainName.like(req.getChainName()));
        }
        booleanBuilder.and(QChain.chain.applicationName.eq(req.getApplicationName()));
        Page<Chain> page = chainRepository.findAll(booleanBuilder,
                                                   PageRequest.of(req.getPageNumber() - 1, req.getPageSize(),
                                                                  Sort.by(Sort.Direction.DESC, "createdAt")));
        return page.map(ChainMapper.INSTANCE::entity2Response);
    }
}
